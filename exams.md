# Теория

#### 1. Основы λ-исчисления. Функции нескольких переменных, каррирование. λ-термы, свободные и связанные переменные.

Программа в функциональной парадигме - это выражение, а её выполнение - вычисление (_редекса_). 

**Функциональный выислитель**:
- Должен находить в выражении _редексы_, которые могут быть непосредственно вычислены.
- Выполнять сокращения редексов по определенным _правилам вычисления_, обычно в терминах подстановки.
- Завершать вычисление, когда редексов нет.

В ФП `=` является связыванием, а **не** присваиванием. 

```haskell
z = 2 * 3 + 7 -- равенство-по-определению
```

Введем понятие функции, в выражении `2 * y + 3` нет редексов, так как они возникнут при конкретной подстановке значения `y`. Следующие выражение представляет собой _лямбда-абстрацию_ или _анонимную функцию_.
```haskell
foo = \y -> 2 * y + 3 -- \ * ->, * - абстрактор, а после -> тело функции.
```

Выражение, в котором анонимная функция применяется к фактическому аргументу, называется _$\beta$-редексом_. Вычислительное правило, заключающееся в подстановке в тело лямбда-абстрации конкретного значения вместо формального, называется _$\beta$-редукцией_. В Haskell используется _ленивая стратегия_, то есть сокращается самый левый внешний редекс.

В выражении `m * 2 + n` абстрация по одной из переменных внесёт _асимметрию_, а если продолжить абстрацию, то получим _замкнутое выражение_. Вычисление такого выражение требует последовательной передачи аргументов, такие функции называют _каррированными_. Внутренний редекс иллюстрирует понятие _частичного применения_ каррированной функции.

```haskell
\n -> (\m -> m * 2 + n)
``` 

**Множество $\lambda$-термов** $\Lambda$ строятся индуктивно из переменных $V = \{ x, y, z, ...\}$ с помощью абстрации и применения:

- $v \in V \Rightarrow v \in \Lambda$
- $M \in \Lambda, N \in \Lambda \Rightarrow MN \in \Lambda$
- $x \in V, M \in \Lambda \Rightarrow \lambda \ x. \ M \in \Lambda$

Применение левоассоциативно, абстрация правоассоциативна, тело абстрации простирается вправо насколько это возможно.

На термах вводят отношение $\beta$-редукции: $(\lambda x. M) \ N \rightarrow_{\beta} [x \rightarrow N] \ M$ (_подстановка N вместо всех вхождений x в M_), то есть мы сократили редекс.

Связывание переменной ограничевается видимостью лямбда-функции, то есть мы её можем повторно связать вне тела. 

```haskell
(\x -> (\x -> x z) x) x -- x дважды связана и свободна, z - свободна.
```

**Множество свободных** переменных терма $FV(T)$ определяется:
- $FV(x) = \{x\}, x \in V$
- $FV(M \ N) = FV(M) \ \cup \ FV(N)$
- $FV(\lambda \ x. \ M) = FV(M) \ \backslash \ \{x\}$

**Множество связанных** переменных $BV(T)$ (_bound_) определяется:
- $BV(T) = \varnothing$
- $BV(M \ N) = BV(M) \ \cup \ BV(N)$
- $BV(\lambda \ x. \ M) = BV(M) \ \cup \ \{x\}$
  
#### 2. Подстановка λ-терма. Комбинаторы, комбинаторная логика.

M - **замкнутрый $\lambda$-терм** (или **комбинатор**), если $FV(M) = \varnothing$. Множество замкнутых термов $\Lambda$ обозначают как $\Lambda^0$. Многим комбинаторам определены общепринятые имена:
- $\Iota = \lambda x.x $
- $\omega = \lambda x. xx$
- $\Omega = \omega \omega$
- $\Kappa = \lambda x y. x$
- $\Kappa_* = \lambda x y. y$
- $C = \lambda f x y. f y x$
- $\Beta = \lambda f g x. f \ (g \ x)$
- $S = \lambda f g x . f \ x \ (g \ x)$

Комбинаторы можно определить как примитивы, задав на них вычислительное поведение на аргументах-переменных. Вычисление задается подстановкой, то есть заменой формального значения на фактическое: $\omega \Iota \rightarrow_{\beta} \Iota \Iota \rightarrow_{\beta} \Iota$.

**!** Если выбрать за базис $S, K$, то полочим равносильное лямбда-исчисление.

Подстановка выполняется только вместо **свободных вхождений** переменной:
$[x \rightarrow \lambda z. z] (x \ (\lambda x. x y) \ x) = ((\lambda z. z) \ (\lambda x. x y) \ \lambda z. z)$. Также существует проблема захвата переменной, это когда мы подставляем значение сместо свободной переменной и оно становится связанной, то есть $[x \rightarrow y] (\lambda y. x \ y)$, тогда получим, что множество $FV$ увеличится.

Для разрешения такой проблемы воспользуемся **соглашением Барендрегта**. Имена связанных переменных будем выбирать так, чтобы они отличались от имен свободных переменных: $[x \rightarrow y] (\lambda y. x \ y) = \lambda y'. y \ y'$. Определим алгоритм подстановки терма:

**Подстановка** терма $N$ вместо свободных вхождений $x$ задает индукционным правилом:

- $[x \rightarrow N]x = N$
- $[x \rightarrow N]y = y$
- $[x \rightarrow N](M \ L) = ([x \rightarrow N]M) \ ([x \rightarrow N]L)$
- $[x \rightarrow N](\lambda x. P) = (\lambda x. P)$
- $[x \rightarrow N](\lambda y. M) = \lambda y. [x \rightarrow N]M, \ y \notin FV(N)$
- $[x \rightarrow N](\lambda y. M) = \lambda z. [x \rightarrow N]([y \rightarrow z]M), \ y \in FV(N), z \notin FV(N) \ \cup \ FV(M)$

Лемма подстановки?

#### 3. α- и β-конверсии. η-конверсия и экстенсиональная эквивалентность.

Основная схема аксиом: $\forall M, N \in \Lambda: (\lambda x. M) \ N =_{\beta} [x \rightarrow N]M$.

**!** Логические аксиомы и правила:
- $M =_{\beta} M$
- $M =_{\beta} N \Rightarrow N =_{\beta} M$
- $M =_{\beta} N, N =_{\beta} L \Rightarrow M =_{\beta} L$

**!** Правила совместимости:
- $M =_{\beta} M' \Rightarrow MZ =_{\beta} M'Z$
- $M =_{\beta} M' \Rightarrow ZM =_{\beta} ZM'$
- $M =_{\beta} M' \Rightarrow \lambda x. M =_{\beta} \lambda x. M'$

Если $M =_{\beta} N$ доказуемо в терминах лямбда-исчисления, то пишут $\lambda \vdash M =_{\beta} N$.

Схема $\alpha$-преобразования: $\lambda y. M =_{\alpha} \lambda z. [y \rightarrow z]M, z \notin FV(M)$.

Схема $\eta$-преобразования: $\lambda x. M x =_{\eta} M, x \notin FV(M)$. Смысл $\eta$-эквивалентности в том, что слева и справа от знака $=$ термы аппликативно ведут себя одинаково: $(\lambda x. Mx) \ N =_{\beta} MN$.

$\eta$-преобразование обеспечивает принцип экстенсиональной эквивадетности двух функций, это когда две функции дают один и тот же результат при любом одинаковом вводе: $\forall N: F N =_{\beta} G N$. Также для $y \notin FV(F) \ \cup \ FV(G)$:
- $Fy =_{\beta} Gy$
- $\lambda y. F y =_{\beta} \lambda y. G y$
- $F =_{\beta \eta} G$

#### 4. Кодирование булевых значений, кортежей в чистом бестиповом λ-исчислении.

Булевы значения в чистом бестиповом $\lambda$-исчислении.

$$
tru = \lambda x y. x = \Kappa \\
fls = \lambda x y. y = \Kappa_{*}
$$

- $not = \lambda x. x \ fls \ tru$
- $and = \lambda \ x \ y. x \ y \ tru \ fls$
- $or = \lambda \ x \ y. x \ (y \ tru \ tru) \ y$
- $xor = \lambda \ x \ y. x \ (y \ fls \ tru) \ y$
- $if = \lambda b \ x \ y. b \ x \ y$

Зададим кортеж и две функции на нем (_взятие элемента пары_).

$$
pair = \lambda x y f. f \ x \ y
$$

- $fst = \lambda p. \ p \ tru $
- $snd = \lambda p. \ p \ fls $

#### 5. Кодирование чисел Чёрча в чистом бестиповом λ-исчислении. Арифметические операции над ними.

Число Чёрча задаются индуктивно:

$$
\hat{0} = \lambda s z . z \\
\hat{1} = \lambda s z . s \  z \\
\hat{2} = \lambda s z . s \ (s \  z) \\
n \in \N, \ X \in \Lambda: \mathcal{F}^n(X) \Rightarrow \mathcal{F}^{n + 1}(\mathcal{F}^n(X))  
$$

Определим операции и функции над числами Чёрча:
- $iszero = \lambda n. \ n \ (\lambda x. \ fls) \ tru$
- $succ = \lambda n s z. \ s \ (n \ s \ z)$
- $plus = \lambda m n s z. \ m \ s \ (n \  s \ z)$
- $mult = \lambda m n s z. \ m \ (n \ s) \ z$
- $power = \lambda m n s z. \ n \ (mult \ m) \ \hat{1} $

В билете нужно доказывать по индукции?

# Haskell

#### 1. Основы программирования на Haskell. Связывания. Рекурсия. Базовые конструкции языка. Частичное применение. Бесточечный стиль.

**Haskell** - чистый (*на низком уровне нет императивных конструкций*) функциональный язык с "ленивой" семантикой и полиморфной статической (_во время компиляции_) типизацией. Назван в честь ученого Хаскелла Брукса Карри, первая реализация которого выпущена в 1990 году.

Plelude (_вступление_) - стандартный модуль языка Haskell, который подгружается по умолчанию.

**Программирование в малом** - выражения. Они стоятся из литералов (и переменных) с помощью функций, операторов и конструкторов данных.

**Кортежи** - гетерогенный объект, минимальной длины - 2, по стандарту должен быть не меньше - 15, а в GHC его длина - 62. Содержит данные произвольного типа. 

**Списки** - гомогенный, тип опредляется элементами (*содержит элементы только одного типа*). Может быть пустым, содержать один элемент, быть бесконечной длины.

**Программирование в среднем** - связывание. Знак равенства задает *связывание* (binding): имя слева связывается с выражением справа.

```haskell
x = 42                      -- глобально
aBC = let z = x + y         -- aBC - глобально, z - локально       
    in z ^ 2                -- layout rule, отступ
y = 7 + 3                   -- глобально
```

**!** Если отступ ненулевой, то это продолжение предыдущей строки.

Связывание переменных - объявление констант или функций нулевой арности (*без аргументов*). Связывание не форсирует вычисление в правой части.

Связывание переменной является частным случаем более общей конструкции - **связывания образцов** (pattern binding).

```haskell
(x, y) = ("A", 42)
```

Если же структура, полученная в результате вычислений, не соответствует образцу, происходит аварийное завершение вычислений при попытке их форсировать.

Равенство может задавать функцию, такое связывание называют **функциональным**.

```haskell
foo x y = 10 * x + y -- foo глобально
                     -- x y локальны
```

Такое связывание называется **динамическим**, когда вместо формальных значений в функцию подставляются фактические.

```haskell
foo x y = 10 * x + y       -- комбинАторный стиль
foo' x = \y -> 10 * x + y  -- смешанный стиль
foo'' = \x y -> 10 * x + y -- лямбда-стиль
```

Функцию, допускающую последовательнкю передачу аргументов, называют **каррированной**.

Композиция функций часто используется и для так называемого бесточечного стиля записи функций.

```haskell
sum' = foldl (+) 0
lg'' = logBase 2        -- также бесточечный стиль
```

Из-за каррирования мы можем пропустить образец xs с обеих сторон, так как sum' - функция, которая принимает на вход список. Такая запись будет **бесточечной** (*pointfree*). **Смысл термина**: в определении отсутствует точка применения функции - её аргумент.

При определении функций мы можем в качестве формальных значений параментров использовать не только переменные, но и образцы. Допускаеися произвольная вложенность образцов.

```haskell
fst (x, y) = x
fstOfSnd (x, (y, z)) = y
```

Каждая из функций задает так называемую **лексическую область видимости** для связываемой переменной. Глобальная область одна, а локальных может быть несколько. В одной лексической области видимости связывание некоторой переменной может происходить не более одного раза.

```haskell
z = 1           -- ok
z = 2           -- error
q q = \q -> q   -- ok

p p p = p       -- в области видимости p повторяется несколько раз, ошибка
p = \p p -> p      -- области видимости лямбда функции также несколько раз идет повторение

p = \p -> (\p -> p)
```

> Вообще транслятор добавляет скобочки, когда переводит  код в AST, а также пребразует большую лямбда-функцию, у которой несколько переменных в абстракторе, в последовательность лямбд.

При переносе кода объявления на следующую строку отступ должен быть больше, чем отступ начала этого объявления. При обнулении отступа начинается новое объявление (*функциональное связывание*).

- Если при переносе отступ оказался равен отступу начала объявления - значит началось новое объявление в той же самой области видимости.
- Если отступ оказался меньше, то это начала объявления более широкой области видимости.
  
```haskell
foo = 
  z
    where z = 
            b
            where b = 
                    10
          y = 10
```

Основным инструментом кодирования повторяющихся вычислений в функциональных языках служит рекурсия. Рекурсивное определение содержит имя определяемой функции в её теле. Корректная реализация должна содержать достижимое терминирующие условие.

Имеется специальное представление $$\bot$$ (основание, дно), маркирующее ошибку времени исполнения. Библиотечная констант undefined - пример "реализации" $$\bot$$. Пример расходящихся вычислений:

```haskell
bot = 1 + bot
fortyTwos = 42 : fortyTwos
```

Вызов fortyThow демонстрирует доступность промежуточных результатов. Haskell обеспечивает возможность воспользоваться этой доступностью: в случае подобной **продуктивной** расходимости мы можем остановить неограниченные рекурсивные вызовы, внешними по отношению к рекурсивно определенной функции.

Полезной техникой является обеспечение рекурсивной функции дополнительным параметром, который используется для передачи между шагами редукции промежуточных значений. Такие параметны называют **аккумуляторами**.

Конструкция `where` позволяет реализовать локальное связывание, оно не порождает внешнее связывание. Конструкция позволяет связывать не только переменные, но и функции. Отступ для каждой нового связывания должен быть один и тот же.

```haskell
roots' a b c = ((-b - sd) / denom, (-b + sd) / denom)
    where {sd=sqrt discr; discr=b^2-4*a*c; denom=2*a}

roots'' a b c = ((-b - sd) / denom, (-b + sd) / denom)
    where sd = sqrt discr
          discr = b ^ 2 - 4 * a * c
          denom = 2 * a
```

После трансляции вид записи (*layout rule*) `where` в `roots''` превращается в `roots'`

Выражение `let .. in ..` отличается от `where` порядком следования блоков, в которых новые имена связываются и используются.

```haskell
roots''' a b c =
    let sd = sqrt discr
        discr = b ^ 2 - 4 * a * c
        denom = 2 * a
    in ((- b - sd) / denom, (- b + sd) / denom)

factorial''' m =
    let helper acc n =
          if n > 1
          then helper (acc * n) (n - 1)
          else acc
    in helper 1 m
```

Также `let .. in ..` это выражение, тип которого совпадает со значением после `in` (*ещё одно отличие от where*).

```haskell
(let x = 3 + 2 in x ^ 2) * 3
```

Имеется удобная синтаксическая конструкция, позволяющая выбирать тело функции на основе анализа логических условий - **охранные выражения** или **предохранитили** (guards). Предохранители просматриваются сверху вниз до первого истинного. Если все пердохранители принимают ложное значение, то программа аварийно завершается, поэтому рекомендуют использовать константу `otherwise`, которая всегда истина.

Кострукция `where` может быть общей для предохранителей. Это делает `where` специальной часть синтаксиса объявления функционального связывания, поэтому мы не можем использовать её как выражение.

```haskell
nRoots' a b c
    | d > 0 = 2
    | d == 0 = 1
    | d < 0 = 0
    where d = b ^ 2 - 4 * a * c
```

#### 2. Основные встроенные типы языка Haskell. Система модулей. Каррирование.

**Программирование в большом** - модули.

- Программа состоит из набора модулей
- Модули позволяют управлять пространством имён
- Инкапсуляция через списки экспорта и испорта

```haskell
module A (foo, bar) where
import B (f, g, h)      -- списка импорта
foo = f g
bar = ...
bas = ...               -- инкапсулирован
```

- Конфликты разрешаются через полные имена
```haskell
import qualified B (f, g, h)
foo = B.f . B.g
```

GHC требует, чтобы каждый модуль был сделан в отдельном файле, а название файла совпадало название модуля. Хотя стандарт не накладывает таких ограничений, то есть оставляет волю творчества разработчикам компилятора.

- import Data.Set as S - псевдонимы.

*Основные типы, встроенные в язык*:
- Bool
- Char
- Int (_ограничен $2^{64}$_), Integer (ограничен количеством памяти в космпьютере)
- Float, Double
- t1 -> t2 -> ... -> tN - тип функции
- (t1, t2, ..., tN) - тип кортежа
- () - единичный тип с константой () (*unit type*)
- \[t1\] - тип списка
  
> Типы списка, кортежа, функции можно записывать в префиксной нотации, например: `[] Double` === `[Double]`.

**::** - оператор связывание выражения и его типа.

Основным способом представлять пользовательские типы данных является объеявление data. Рассмотрим на примере стандартного типа Bool, который представлен в виде перечисления.

```haskell
data Bool = True | False
```

Слева обозначен конструктур типа, а справа конструктор данных. На самом деле с технической точки зрения образец - это конструктор данных, находящийся, правда, влевой части.

**!** Функциональная стрелка правоассоциативна.

```haskell
foo x y = x * 10 + y   -- Int -> Int -> Int
bar = foo 4            -- Int -> Int, частично применённая функция
bar 2                  -- Int 
```

В функции нескольких переменных, если при сопоставлении с образцом нам не требуются переменные для реализации тела, то можно использовать wildcard (*джокер*).

Функции, которые мы можем вызывать от любых аргументов называются полиморфными. Тип таких функции не состоит из конкретный значений, а состоит из переменных типа (*параметрический полиморфизм*).

```haskell
const :: p1 -> p2 -> p1

const (5 :: Int) :: p2 -> Int -- вместо значений подставляется конкретный тип

id id :: a -> a -- полиморфизм сохраняется, 
-- если фактически переданный агргумент сам является полиморфным 

const id :: b -> a -> a
```

Можно управлять конкретизацией полиморфной функции, и отдельно передавать её параметр конкретного типа. Для этого подключим расширение `XTypeApplications`. Чтобы отличать код применения от обычного, перед именем типа используется символ `@`, например: `id @Bool`.

**Классы типов** позволяют наложить специальные ограничения (ad hoc) на полиморфный тип.

```haskell
foo :: Num a => a -> a -> a
foo x y = 10 * x + y
```

Контекст `Num a` накладывает на тип `a` ограничения: для него должны быть определены операторы сложения, умножения и и т.п. 

```haskell
class Num a where
    (+) :: a -> a -> a
    (-) :: a -> a -> a
    (*) :: a -> a -> a
```

Перечислим на пример функции наболее часто используемые стандартные классы типво. Среди них класс `Eq`, отвечающий за сравнение на равенство, `Ord` - порядковые сравнения, `Enum` - отвечает за итерации (succ, pred), `Show`/`Read`.

Все числовые типы являются представителем класса `Num`. Типы даных `Int`, `Integer` являются представителями класса типов `Integral` (целочисленное деление), а `Float` и `Double` представителями `Floating`, `Fractional`, а тип данных `Rational` - только `Fractional`.

**Функции высших порядков** - функции, имеющие стрелочные аргументы. Определение в Википедии содержит продолжение " . . .или возвращаемым значением которой служит функция". Однако для языков с каррированными функциями такое определение не очень подходит, поскольку при этом любая функция более чем одного аргумента является ФВП.

Функция `curry` принимает функцию над парой, а возвращает функцию, принимающую два последовательных аргумента.

Функция `uncurry` делает обратное.

Функция `flip` меняет порядок аргументов (комбинатор C).

```haskell
curry :: ((a, b) -> c) -> a -> b -> c
curry f = \ x y -> f (x, y)

uncurry :: (a -> b -> c) -> (a, b) -> c
uncurry f = \p -> f (fst p) (snd p)

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

infixl 1 &
(&) :: a -> (a -> b) -> b
(&) = flip ($)

{-
import Data.Function
3 & (*10) & (+40) == 70
-}
```

механизм default?


#### 3. Операторы и их сечения в Haskell.

Оператор - это комбинация из одного или более символов.

> ! # $ % & * + . / < > ? @ ^ | - ~     = \     :

- Все операторы *бинарные* и *инфиксные*.
- Исключение: унарный префиксный минус, который ссылкается на Prelude.negate.
- Операторы, начинающиеся на двоеточие, должны быть конструкторами данных.
- Операторы могут использоваться в префиксном (функциональном) стиле.
- Функции могут использоваться в инфиксном (операторном) стиле.
  
Новосозданный оператор имеет 9 приоритет и левую ассоциативность.

С помощью `infixl`, `infixr`, `infix` задается приоритет (0 до 9) и ассоциативность.

```haskell
infixl 6 *+*
```

Функциям тоже можно задавать приоритет `infix 5 'plusminus'`

`infix` отвергает цепочки, используем, когда не хотим неявно подразумевать скобки в цепочках операторов.

- `infixl 9 !!`
- `infixr 9 .`
- `infixr 8 ^, ^^, **`
- `infixl 7 * /, 'quot', 'rem', 'div', 'mod'`
- `infixl 6 +, -`
- `infixr 5 ++, :`
- `infix 4 ==, <=, <, >=, >, 'elem', 'notElem'`
- `infixr 3 &&`
- `infixr 2 ||`
- `infixl >>=, >>`
- `infixr 1 =<<`
- `infixr 0 $, $!, 'seq'`

> Применение имеет наивысший приоритет (10).

- Оператор аппликации, задает применение, но самым низким приоритетом. ($)
- Используется дли элиминации избыточных скобок.

Операторы на самом деле просто функции, которые также докупскают частичное применение. **Сечение** - синтаксический сахар для частичного применения как к левому, так и к правому аргументу. **Левое сечение**: (2 +&&+) == (+&&+) 2 == \y -> 2 +&&+ y. **Правое сечение** связывает правый аргумент оператора, то есть второй, если перевести оператор в функциональный стиль: (+&&+ 3) == \x -> x +&&+ 3.

> Скобки обязательный синтаксис сечений!

```haskell
(^2) . (5+) $ 2 -- 49, демонстрация композиции функций через сечение.
```

Оператор евро (&, есть в предыдущем билете) разворачивает конвейер вычислений.

#### 4. Строгие и нестрогие функции. Ленивое и энергичное исполненние. Форсирование, слабая головная нормальная форма.

Функция, игнорирующая свой аргумент, называется **нестрогой** по отношению к этому аргументу. **Строгая** же функция на расходящихся значениях расходится, то есть *обладает свойством* $$f \bot = \bot$$. Если функция завершается при всех нерасходящихся значениях, то она называется **тотальной**, в ином случае - **частичной**.

Haskell гарантирует вызов-по-необходимости, поэтому не будет вычислять аргумент, если функция нестрога к нему. В ином случае, если аргумент используется несколько раз в теле функции, то используется **механизм разделения**. Для того, чтобы не вычислять аргумент несколько раз, на него передаются ссылки, а не само значение. Также используется **контекст вычислений**, когда используют промежуточную переменную:

```haskell
foo y = let x = y in (x * 3, 15 + x)
```

Сопоставление с образцом происходит только до WHNF, когда элемент форсирует значение до конструктура. Образцы вносят энергичность в вычисления.

В Haskell можно локально прийти к энергичной модели вычислений по требованию программиста. Для форсирования вычислений используют `seq` == $$\Kappa_*$$.

```haskell
seq :: a -> b -> b
seq | b = |             -- | - bottom
seq a b = b             -- a /= |
```

- Seq нарушает ленивую семантику, позволяя форсировать вычисления без необходимости.
- Seq форсирует вычисление первого аргумента, если у него есть редекс на верхнем уровне.
- Однако конструкторы, абстрации и частично примененные функции, являются "значениями", обеспечивают барьер для распространения расходимости, то есть `seq` форсирует до WHNF.
- Подобные "не редексы" объединяются одним термином - их называют слабой головной нормальной формой (WHNF).

```haskell
seq (undefined, undefined) 42   -- 42
seq (\x -> undefined) 32        -- 42
seq ((+) undefined) 42          -- 42
```

С помощью `seq` реализован оператор форсирующего применения.
```haskell
infixr 0 $!
($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x
```

Из-за ленивости какая-нибудь функция факториала будет иметь **thunk**, оптимизатор GHC, конечно, будет справляться с некоторыми оптимизациями, но стоит в таких случаях сразу форсировать значение/аккамулятор и т.д.

#### 5. Списки, стандартные функции для работы с ними. Генерация (выделение) списков.

Присутствуют два конструктура списка:
- []    :: [a]
- (:)   :: a -> [a] -> [a], infixr 5 :
- [1, 2, 3] == 1:(2:(3:[])) == 1:2:3:[]
  
В современном Haskell не рекомендуется использовать частичные функции (возвращают undefined): `head`, `tail` (O(1)).

```haskell
head :: [a] -> a
tail :: [a] -> [a]
```

ФПН для списков: `filter`, `map` (O(n));

```haskell
filter :: (a -> Bool) -> [a] -> [a]
map :: (a -> b) -> [a] -> [b]
```

Другие функции для списков: `(++)`, `take`, `drop`, `zip`, `zipWith`, `elem`, `lookup`, `(!!)`, `takeWhile`, `dropWhile` (O(n))

```haskell
take :: Int -> [a] -> [a]
take n _    | n <= 0    = []
take _ []               = []
take n (x:xs)           = x : take (n - 1) xs

zip :: [a] -> [b] -> [(a, b)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
```

"Бесконечные" структуры данных описываются рекурсией. Благодоря ленивости вычсиляется только то, что требуется:

```haskell
ones = 1 : ones         -- продуктивная расходимость
numsFrom n = n : numsFrom (n + 1)
squares = map (^2) (numsFrom 0)
take 10 squares         -- [0, 1, 4, .., 81]
```

Имеется компактный способ описывать большие "регулярные" списки:
- [1..10]
- [1,3..17] с шагом 2, [1,3,5,7,..17], шаг задается = 3 - 1
- ['A'..'z']
- [1..]
  
Есть инструмент выделения списков (*list comprehensions*). 
- При нескольких генераторах обновляется быстрее самый правый.
- Следующие генераторы могут использовать значения предыдущих.
- Доступно использование предикатов.
- Можно использовать сопоставление с образцом.

```haskell
[a + b | (x, y) <- digits, a <- [1..x], b <- [1..y], a + b /= 0]
```

#### 6. Алгебраические типы данных. Сопоставление с образцом, его семантика. Полиморфные и рекурсивные типы данных.

Пользовательские типы данных строятся из базовых с помощью трёх операций над типами: суммы, произведения, возведения в степень.

```haskell
data Bool = False | True
```

Такой тип данных называется **перечислениями** (тип с 0-арными конструктурами данных). Строятся они с помощью оператора `|`. Типы, построенные с помощью такого оператора, называются типами суммы.

Компилятор можно попросить для нашего типа сгенерировать код: например вывод конструктур типа, используя механизм **производных представителей**.

```haskell
data CardinalDirection = North | East | South | West deriving Show
```

Встроенные типы ведут себя так, как будто они опеределены как перечисления. Это позволяет использовать литералы как образцы.

- Сопоставление с образцом идет сверху вниз, затем слева направо.
- Сопоставление бывает:
  - удачным
  - неудачным
  - расходящимся (*не происходит паттернг матчинг, или доведение до WHNF доводит до расходимости*)

Образцы бывают **опровержимыми** и **неопровержимыми**. Последними являются переменные или подчеркивание.

Декартово произведение нескольких типов - это тип, в котором лежат значения всех сомножителей.

```haskell
data PointDouble = PtD Double Double deriving Show
```

**!** Из-под конструктура типа можно доставать значения.

Универсальным решением будет реализовать полиморфный интерфейс к точке, для это параметризуем её.

```haskell
data Point a = Pt a a deriving Show
```

Теперь конструктор типа Point не просто тип, а функция над типами! 

Система типов над системой типов называется система **кайндов**.

```haskell
>> :kind Double
Double :: *

>> :kind Point
Point :: * -> * -- однопараметрический оператор из простого типа в простой тип

>> :k []
[] :: * -> * -- ожидает тип в контейнер,
-- также (,) только два элемента, (->)
```

Полиморфные типы данных полиморфны параметрически (*на типовой параметр невозможно наложить ограничения*), над ними нельзя наложить `ad hoc` ограничения (в старых версиях можно). 

**Экспоненциальный тип** - это тип функции. Такое название происходит из наблюдения за мощностями типов, то есть количеством их элементов. У типа `Bool` мощность типа равна 2, у типа `Ordering` - 3. У типа суммы `Either Odering Bool` 3 + 2 = 5. У типа произведния `(Bool, Ordering)` 2 * 3 = 6. Если подсчитать число различных значений функций типа `Bool -> Ordering`, то окажется 3^2, если же типа `Ordering -> Bool`, то 2^3. Это полноценный тип языка, мы можем использовать её повсюду, в частности использовать его в качестве типа аргумента конструктура данных.

```haskell
data Endom a = Endom (a -> a) -- функции, у которых можество определения и значения совпадают
```

При объявлении типов можно использовать рекурсию, допустимо указывать объявляемый тип в качестве аргумента конструктура данных.

```haskell
data Nat = Zero | Suc Nat deriving Show
```

#### 7. Трансляция образцов в Kernel. Синонимы в образцах, ленивые и охранные образцы. Образцы в λ- и let-выражениях.

На низком уровне (Kernel) все уровнения транслируются (их pattern matching) в конструкцию `case of`. 

```haskell
head' (x:_)      = x
head' []         = error "head: empty list"

--      |
--      v

head'' xs        = case xs of
    (x:_)        -> x
    []           -> error "head: empty list"
```

Общее правило трансляции:

```text
f p11 p12 .. p1k = e1
..
f pn1 pn2 .. pnk = en

    |
    v

f x1 x2 .. xk = case (x1, x2, .., xk) of
    (p11, p12, .., p1k) -> e1
    ..
    (pn1, pn2, ... pnk) -> en
```

**!** `case of` является выражением, поэтому его, как и `let in`, можно использовать в любом месте программы.

Иногда мы в левой части функции деконструим структуру, то есть пишем сложный образец, но в правой части нам может понадобится собрать его обратно. Для этого образцу можно дать локальное имя, воспользовавшись **as-образцами** (`@`).

У нашего класса неопровержимых образцов настало поплнение: **ленивые образцы**. Ленивый образец - это любой образец, к которому приписана `~`, сопоставление с ним всегда успешно, но динамическое связывание откладывается до момента фатктического использования в правой части. То есть ленивый образец форсирует сопоставление, только если хотя бы один из элементов понадобился для вычисления правой части.

Ленивые образцы повышают степень определенности функции, элиминируя ряд потенциальных расходимостей.

```haskell
(***) :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
(***) f g ~(x, y) = (f x, g y)

(const 1 *** const 2) undefined         -- (1, 2)
```

В `let in`-выражениях и конструкции `where` можно не только связывать переменные, но и сопоставлять с образцами.

```haskell
doubleTail ys = let (_:xs) = ys
    in xs ++ xs
```

В Kernel это транслируется так:
```
let p = e1 in e0 
    == 
case e1 of ~p -> e0 
```

**!** Обратим внимание, что в `let` ленивое (*неопровержимое*) сопоставление с образцом.
```haskell
let x:xs = undefined in 42      -- 42
let x:xs = undefined in x       -- undefined
answer ys = 42 where x:xs = ys  -- в where тоже ленивые образцы
```

В лямбда-абстракциях тоже разрешено использовани образцов. Недостаток только в том, что для одного аргумента лямбды - один образец.

```text
\p1 p2 .. pk -> e1 
    ==
\x1 x2 .. xk -> case (x1, x2, .., xn) of (p1, p2, .., pn) -> e1
```

**!** Любое сопоставление с образом начинается после полного примения.

```haskell
test = \(Just x) (Right y) -> x + y
```

> В Haskell 2010 добавили возможность использовать образцы в *охранных выражениях*, **охранные образцы**.

Если раньше охранные выражение принимали `Bool`, то теперь может значение любого типа. Удачное сопоставление приводит к правой части определения функции, неудачное - к переходу к следующему предохранителю.

```haskell
firstOddIsBig :: [Integer] -> Bool
firstOddIsBig xs
  | Just x <- find odd xs, x > 1000 = True
  | otherwise = False
```

#### 8. Объявления type и newtype. Метки полей. Строгие конструкторы данных.

```haskell
data Point a = Pt a a
```

Для типов произведения можем проименовать поля, воспользовавшись механизмом **меток полей**.

```haskell
data Point a = Pt {ptX :: a, ptY :: a}
```

Типы данных, поля которых снабжены метками, называются **записями**. Имеет возможность инициализировать не только через конструктор, а ещё через метки полей:

```haskell
p1 = Pt {ptX = 3, ptY = 5} -- порядок может быть произвольным, инициализировать можно не всех
```

```haskell
absP p = sqrt (ptX p ^ 2 + ptY p ^ 2) -- проекция
absP' Pt {ptX = x, ptY = y} = sqrt (x ^ 2 + y ^ 2) -- можно выбрать сколько нужно полей
```

С помощью "меток полей" можно обновлять записи

```haskell
>> myPt = Pt {ptX = 3, ptY = 8}
>> myPt {ptX = 10}
Pt {ptX = 10, ptY = 8} -- новая запись, которая разделяет старый ptY с myPt
>> myPt
Pt {ptX = 3, ptY = 8}
```

Метки полей одного типа могут быть общими в нескольких конструктурах данных для типа суммы произведений.

```haskell
data Homo = Known { name :: String, male :: Bool }
          | Unknown { male :: Bool }
```

**!** Метки являются глобальными именами!

Ключевое слово `type` задает **синоним типа**. Классическим примером является `type String = [Char]`. Синонимы типов вводятся исключительно для удобства и играют чисто синтаксическую роль. Синонимы типа могут быть параметризованными:

```haskell
type EC = Either Char

>> :kind EC   -- * -> *, это однопараметрический конструктор типа
```

Если явно припысывать этот тип, то интерпретатор предъявит именно этот синоним. Это поведение не очень устройчиво к преобразованиям, требующим вывода типа.

Ключевое слово `newtype` задаёт **новый тип* с единственным однопараметрическим конструктором, упаковывающим уже существующий тип.

...

#### 9. Классы типов. Объявления представителей. Классы типов Eq, Ord, Enum и Bound.

class instance
eq 
ord (минимально полное опр) + законы (реф, транз, антисим, сравниваемость)
enum (минимальное полное определение)
bounded

#### 10. Внутренняя реализация классов типов.
механизм передачи словарей, представители транслируются в функции, возвращающие словарь или функции, принимающие некоторый словарь и возвращающте более сложный словарь

#### 11. Стандартные классы типов: Num и его наследники, Show и Read.
class num (минимальное полное определение)
наследники
иерархия

#### 12. Полугруппы и моноиды. Представители класса типов Monoid.
бинарная ассоциативная операция у полугруппы, закон ассоциативности

смотреть на объекты более абстрактно

stimes 4 "A" = "AAAA" (logn)

e <> e <> e <> ... <> e - все равно как раставлять скобки =>
(e <> e) <> (e <> e) <> ... <> (e <> e)
n/2 - e <> e
или n/4 ((e <> e) <> (e <> e)) => повторно не считаем, поэтому O(logn). Посмотреть на реализацию stimesDefault! Тут показана мощь законов.

явно обеспечиваем с помощи системы типов непустоту списка в sconcat.

моноид получил базовый класс полугруппы, поэтому mappend наследует реализацию ассоциативного оператора

с помощью newtype упаковывает bool и реализовываем интерфейс моноида для одного типа данных

нейтральные элементы True, False

min -> MaxBound 
max -> MinBound 

deriving Num??? что за интерфейс предоставляется?
(все операции??)

coerce?

#### 13. Свёртки списков. Правая и левая свёртки. Энергичные версии. Развертки. Правило foldr/build.

в foldl ini работает как аккамулятор на каждой итерации

вызывает сама себя, пока список не закончится, то есть нарастает thunk

лучше пользоваться строгой версией foldl', чтобы форсировать вычисления

все левые свертки имеют плохое свойство: они вызывают сами себя до тех пор пока список не закончится
функция f не окажется в головной позиции, поэтому левая свертка всегда зависает, когда в нее передают бесконечный список

бесконечные списки - правая
левая - эффективная в строгой версии

свертки без ini

scanl последовательность шагов левой свертки
левый скан хорошо работает с бесконечными списками

`(#)` - можно использовать идентификатор (sm (#) (x, y) = x # y)

правый скан, чтобы что-то вернуть должен дойти до конца списка

развертка (unfoldr) - итератор
[ini, g ini, g (g ini), `g $ g $ g ini`, ..]
unfoldr использует много техник + законы

iterate = [x, f x , f f x, ...]

build и foldr взаимообртаные

оптимизации продьюсеры и консьюмеры

#### 14. Класс типов Foldable и его представители.

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr :: (a -> b -> b) -> b -> t a -> b, 

t :: * -> * контейнер
a :: *      элемент
t a :: *

для моноида можно использовать mappend <>, а в качестве нейтрального mempty

foldMap имеет четкие типы для foldr

foldMap :: Monoid m => (b -> m) -> Either a b -> m
так как b свободный параметр, то Foldable именно так выглядит как выглядит

foldMap :: (b -> m) -> (a, b) -> m foldable для пары

foldable требует однопараметрический тип контейнера

maximum (100, 42) вернется 42 хихи-хаха

законы foldable?!

#### 15. Класс типов Functor и его представители.

fmap :: (a -> b) -> f a -> f b
f :: * -> * контейнер

стрелка поднимается на уровень контейнера

(<$>) = fmap (инфиксный оператор fmap)

то куда указывает стрелочка, оттуда берутся значения 

(<$) :: a -> f b -> f a
сохраняет структуру контейнера, слева берется значение, справа берется контейнер и помещает туда значение

void - контейнер сохранился, но информация потерялась

<&> инверсия <$>

представители Either, (,), (->)

пересборка типов важна? типа тип не измениться, если не пересобирать

элемент = значение
контекст = вычислительный контекст

<$> левая ассоциативность

f <$> g <$> xs =>
(f . g) <$> xs - так это происходит

законы функторов

не каждый тип может быть функтором
например, эндоморфизм 

#### 16. Класс типов Applicative и его представители.

<*> левая ассоциативность из-за постановки задачи (ap - application аппликация)

контейнер функции к контейнеру аргументов, чтобы строить цепочки fmap2 fmap3

закон, связывающий functor и applicative

($)   :: (a -> b) -> a -> b
(<$>) :: (a -> b) -> f a -> f b
(<*>) :: f (a -> b) -> f a -> f b

(Just g) <*> x = fmap g x -- эталонная реализация, fmap умеет обрабатывать Nothing, Just

liftA2 (+) Just 3 Just 5 
<=>
 (+) <$> Just 3 <*> Just 5


interchange переставили функцию и аргумент, где аргумент частично применили
 
модель каждый с каждым для аппликатива списка, хотя есть две реализации

pure x = [x] однозначная реализация, чтобы отсутствовал эффект и выполнялись законы

для ziplist pure x = ZipList (repeat x)

[1, 2, 3] - три вычисления
"AB" - два вычисления

[1, 2, 3] <* "AB" - шесть вычисление, а значения берутся из [1, 2, 3] по семантике каждый с каждым

[1, 1, 2, 2, 3, 3 ]

<$> <$ $>
<*> <* *>
<&>

#### 20. Монады. Класс типов Monad. Монада Identity. Законы монад. do-нотация.

a -> m b
m :: * -> *

m - контекст
b - значение

эффект 

>> равносильны семантически *> 

код у которого не реализовал monadfail не проходит тайп чекинг